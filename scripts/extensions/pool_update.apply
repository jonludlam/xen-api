#!/usr/bin/env python

import xmlrpclib
import sys
import XenAPI
import time
import json
import urllib2
import xml.dom.minidom
import traceback
import subprocess
import os
import re
import StringIO
import fasteners

UPDATE_DIR = '/var/update/'
TMP_DIR = '/tmp/'
PATCH_ALREADY_APPLIED = 'PATCH_ALREADY_APPLIED'
PATCH_APPLY_FAILED = 'PATCH_APPLY_FAILED'
OTHER_OPERATION_IN_PROGRESS = 'OTHER_OPERATION_IN_PROGRESS'
PATCH_PRECHECK_FAILED_UNKNOWN_ERROR = 'PATCH_PRECHECK_FAILED_UNKNOWN_ERROR'
FIST_FILE = '/tmp/fist_allowed_unsigned_updates'


class ApplyFailure(Exception):
    pass


def success_message():
    rpcparams = {'Status': 'Success', 'Value': None}
    return xmlrpclib.dumps((rpcparams, ), '', True, allow_none=True)


def failure_message(code, params):
    rpcparams = {
        'Status': 'Failure', 'ErrorDescription': json.dumps([code] + params)}
    return xmlrpclib.dumps((rpcparams, ), '', True)


def execute_apply(session, update_package):

    FNULL = open(os.devnull, 'w')

    # yum.conf is located at /var/update/<uuid>/yum.conf
    update_uuid = session.xenapi.pool_update.get_uuid(update)
    yum_conf = os.path.join(UPDATE_DIR, update_uuid, 'yum.conf')

    allow_unsigned = False
    if os.path.isfile(FIST_FILE):
        allow_unsigned = update_uuid in open(FIST_FILE, 'rb').read().split()
    nogpgcheck = ' --nogpgcheck ' if allow_unsigned else ' '

    subprocess.call(
        'cp ' + yum_conf + ' /tmp/yum.conf', shell=True, stdout=FNULL, stderr=FNULL)
    retcode = subprocess.call('yum -c ' + yum_conf + ' install -y ' +
                              nogpgcheck + update_package, shell=True, stdout=FNULL, stderr=FNULL)

    if retcode != 0:
        raise ApplyFailure(
            'Failed to install update_package (%r).' % update_package)


if __name__ == '__main__':
    txt = sys.stdin.read()
    params, method = xmlrpclib.loads(txt)

    session = None
    session = XenAPI.xapi_local()
    session.xenapi.login_with_password('root', '', '', 'Pool_update')
    update = params[1]
    host = params[2]

    try:
        # Check if the update has been applied.
        if update in session.xenapi.host.get_updates(host):
            print(failure_message(
                PATCH_ALREADY_APPLIED, ['This update has already been applied.']))
            sys.exit(0)

        # To prevent the race condition of invoking apply, set a lock.
        update_uuid = session.xenapi.pool_update.get_uuid(update)
        lock_file = os.path.join(TMP_DIR, update_uuid)
        lock = fasteners.InterProcessLock(lock_file)
        lock_acquired = lock.acquire(blocking=False)

        if not lock_acquired:
            print(failure_message(
                OTHER_OPERATION_IN_PROGRESS, ['Another apply operation is in progress.']))
            sys.exit(0)

        # Run precheck
        try:
            session.xenapi.pool_update.precheck(update, host)
        except Exception as e:
            print(
                failure_message(PATCH_PRECHECK_FAILED_UNKNOWN_ERROR, ['%s' % str(e)]))
            sys.exit(0)

        # Apply the update.
        try:
            session.xenapi.pool_update.attach(update, host)
            update_package = session.xenapi.pool_update.get_name_label(update)
            execute_apply(session, update_package)

            # Update database.
            # The fields are RO, set them to RW will get them udpate-able by any client.
            # TODO: Get a feasible solution and update accordingly.
            # session.xenapi.host.get_updates(host):
            # session.xenapi.pool_update.set_hosts(session.xenapi.pool_update.get_hosts() + host)
            print(success_message())
        except Exception as e:
            print(failure_message(PATCH_APPLY_FAILED,
                                  ['Apply failed: %s' % e + traceback.format_exc()]))
        finally:
            session.xenapi.pool_update.detach(update, host)
    finally:
        if lock_acquired:
            lock.release()
            if os.path.isfile(lock_file):
                os.remove(lock_file)
        if session is not None:
            session.xenapi.session.logout()
